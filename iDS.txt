1.Ceaser chipher
def encrypt(text, shift):
    result = ""
    for char in text:
        if char.isalpha():
            shift_base = 65 if char.isupper() else 97
            result += chr((ord(char) - shift_base + shift) % 26 + shift_base)
        else:
            result += char
    return result


def decrypt(cipher, shift):
    result = ""
    for char in cipher:
        if char.isalpha():
            shift_base = 65 if char.isupper() else 97
            result += chr((ord(char) - shift_base - shift) % 26 + shift_base)
        else:
            result += char
    return result


plain_text = input("PLAIN TEXT : ")
shift = 3

cipher_text = encrypt(plain_text, shift)
print("CIPHER TEXT:", cipher_text)

decrypted_text = decrypt(cipher_text, shift)
print("PLAIN TEXT:", decrypted_text)
--------------------------------------------------

2. modified ceaser cipher
def encrypt(text, shift):
    result = ""
    for char in text:
        if char.isalpha():
            shift_base = 65 if char.isupper() else 97
            result += chr((ord(char) - shift_base + shift) % 26 + shift_base)
        else:
            result += char
    return result


def decrypt(cipher, shift):
    result = ""
    for char in cipher:
        if char.isalpha():
            shift_base = 65 if char.isupper() else 97
            result += chr((ord(char) - shift_base - shift) % 26 + shift_base)
        else:
            result += char
    return result


plain_text = input("PLAIN TEXT : ")
shift = int(input("ENTER SHIFT VALUE: "))

cipher_text = encrypt(plain_text, shift)
print("CIPHER TEXT:", cipher_text)

decrypted_text = decrypt(cipher_text, shift)
print("PLAIN TEXT:", decrypted_text)
-----------------------------------------------------------------------------
3.Rail Fence
def encrypt(text, key):
    rail = [""] * key
    row, step = 0, 1

    for ch in text:
        rail[row] += ch
        if row == 0:
            step = 1
        elif row == key - 1:
            step = -1
        row += step

    return "".join(rail)


def decrypt(cipher, key):
    n = len(cipher)
    pattern, row, step = [], 0, 1

    # Create zig-zag pattern
    for _ in range(n):
        pattern.append(row)
        if row == 0:
            step = 1
        elif row == key - 1:
            step = -1
        row += step

    # Count how many letters go in each rail
    rails, idx = [""] * key, 0
    for r in range(key):
        count = pattern.count(r)
        rails[r] = list(cipher[idx:idx + count])
        idx += count

    # Reconstruct plaintext
    pos = [0] * key
    plain = ""
    for r in pattern:
        plain += rails[r][pos[r]]
        pos[r] += 1

    return plain


# Driver code
plain = input("PLAIN TEXT : ")
key = int(input("ENTER KEY (rails): "))

cipher = encrypt(plain, key)
print("CIPHER TEXT:", cipher)

back = decrypt(cipher, key)
print("PLAIN TEXT:", back)
------------------------------------------------------------------------
4.OTP
import random
import string

def generate_otp(length=6):
    chars = string.digits   # only numbers (0-9)
    return ''.join(random.choice(chars) for _ in range(length))

# Generate OTP
otp = generate_otp()
print("Your OTP is:", otp)

# Verify OTP
user_input = input("Enter OTP: ")
if user_input == otp:
    print(" OTP Verified Successfully")
else:
    print(" Invalid OTP, Try Again")
-----------------------------------------------------------------------
5.columnar
A.
def encrypt_columnar(plain, key):
    plain = plain.replace(" ", "").upper()
    n = len(key)
    rows = (len(plain) + n - 1) // n
    matrix = [['' for _ in range(n)] for _ in range(rows)]
    k = 0
    for i in range(rows):
        for j in range(n):
            if k < len(plain):
                matrix[i][j] = plain[k]
                k += 1
    order = sorted([(ch, i) for i, ch in enumerate(key)])
    cipher = ""
    for _, j in order:
        for i in range(rows):
            if matrix[i][j] != '':
                cipher += matrix[i][j]
    return cipher


def decrypt_columnar(cipher, key):
    n = len(key)
    rows = (len(cipher) + n - 1) // n
    order = sorted([(ch, i) for i, ch in enumerate(key)])
    matrix = [['' for _ in range(n)] for _ in range(rows)]
    k = 0
    for _, j in order:
        for i in range(rows):
            if k < len(cipher):
                matrix[i][j] = cipher[k]
                k += 1
    plain = ""
    for i in range(rows):
        for j in range(n):
            if matrix[i][j] != '':
                plain += matrix[i][j]
    return plain


plain = input("PLAIN TEXT: ")
key = input("ENTER KEY: ")
cipher = encrypt_columnar(plain, key)
print("CIPHER TEXT:", cipher)
back = decrypt_columnar(cipher, key)
print("PLAIN TEXT:", back)
--
B.
def encrypt_columnar(plain, key):
    plain = plain.replace(" ", "").upper()
    n = len(key)
    rows = (len(plain) + n - 1) // n
    matrix = [['' for _ in range(n)] for _ in range(rows)]
    
    k = 0
    for i in range(rows):
        for j in range(n):
            if k < len(plain):
                matrix[i][j] = plain[k]
                k += 1

    # Determine order of columns based on key
    order = sorted([(ch, i) for i, ch in enumerate(key)])
    cipher = ""
    for _, j in order:
        for i in range(rows):
            if matrix[i][j] != '':
                cipher += matrix[i][j]
    return cipher

def decrypt_columnar(cipher, key):
    n = len(key)
    rows = (len(cipher) + n - 1) // n
    order = sorted([(ch, i) for i, ch in enumerate(key)])
    
    matrix = [['' for _ in range(n)] for _ in range(rows)]
    k = 0
    for _, j in order:
        for i in range(rows):
            if k < len(cipher):
                matrix[i][j] = cipher[k]
                k += 1

    plain = ""
    for i in range(rows):
        for j in range(n):
            if matrix[i][j] != '':
                plain += matrix[i][j]
    return plain

def encrypt_double(plain, key1, key2):
    first = encrypt_columnar(plain, key1)
    second = encrypt_columnar(first, key2)
    return second

def decrypt_double(cipher, key1, key2):
    first = decrypt_columnar(cipher, key2)
    second = decrypt_columnar(first, key1)
    return second

# Main Program
plain = input("PLAIN TEXT: ")
k1 = input("ENTER FIRST KEY: ")
k2 = input("ENTER SECOND KEY: ")

cipher = encrypt_double(plain, k1, k2)
print("CIPHER TEXT:", cipher)

back = decrypt_double(cipher, k1, k2)
print("PLAIN TEXT:", back)
output:NAME
1234
4321
--------------------------------------------------------------------
6.DES
from Crypto.Cipher import DES

def pad(text):
    while len(text) % 8 != 0:
        text += ' '
    return text

def des_encrypt(plain_text, key):
    des = DES.new(key, DES.MODE_ECB)
    padded_text = pad(plain_text)
    encrypted_text = des.encrypt(padded_text.encode('utf-8'))
    return encrypted_text

def des_decrypt(encrypted_text, key):
    des = DES.new(key, DES.MODE_ECB)
    decrypted_text = des.decrypt(encrypted_text).decode('utf-8').strip()
    return decrypted_text

plain = input("Enter Plain Text: ")
key = b'8bytekey'

cipher = des_encrypt(plain, key)
print("Cipher Text (bytes):", cipher)

back = des_decrypt(cipher, key)
print("Decrypted Text:", back)

install this if modulenot found
-m pip install pycryptodome
-------------------------------------------------------------
7.Monoalpha
def encrypt(text, key):
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    text = text.upper()
    result = ""
    for ch in text:
        if ch.isalpha():
            result += key[alphabet.index(ch)]
        else:
            result += ch
    return result

def decrypt(text, key):
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    result = ""
    for ch in text:
        if ch.isalpha():
            result += alphabet[key.index(ch)]
        else:
            result += ch
    return result


# ----- MAIN PROGRAM (Simplified) -----
key = input("Enter 26-letter key (Aâ€“Z only): ").upper()
msg = input("Enter message: ")

enc = encrypt(msg, key)
print("\nEncrypted:", enc)

dec = decrypt(enc, key)
print("Decrypted:",dec)
------------------------------------------------------------------------
8.IDEA
def mod_mul(a, b):
    return ((a or 0x10000) * (b or 0x10000)) % 0x10001 & 0xFFFF

def mod_add(a, b):
    return (a + b) & 0xFFFF

def encrypt_char(ch, key):
    val = ord(ch)
    val = mod_add(val, key)
    val = mod_mul(val, key)
    return val

def decrypt_char(val, key):
    val = mod_mul(val, pow(key, -1, 0x10001))
    val = mod_add(val, -key)
    return chr(val)

plain = input("Enter text: ")
key = int(input("Enter key (1-65535): "))

cipher = [encrypt_char(c, key) for c in plain]
print("Encrypted:", cipher)

decrypted = ''.join([decrypt_char(c, key) for c in cipher])
print("Decrypted:",decrypted)
---------------------------------------------------------------------------
9.RC4
def rc4(data, key):
    S = list(range(256))
    j = 0
    key = [ord(c) for c in key]

    # Key Scheduling
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]

    # Pseudo-Random Generation
    i = j = 0
    out = ""
    for char in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        K = S[(S[i] + S[j]) % 256]
        out += chr(ord(char) ^ K)
    return out


# ---- Main Program ----
plain = input("Enter plaintext: ")
key = input("Enter key (any text): ")

# Encrypt
cipher = rc4(plain, key)
cipher_hex = cipher.encode().hex()
print("\nEncrypted (hex):", cipher_hex)

# Decrypt
decrypted = rc4(cipher, key)
print("Decrypted:",decrypted)
-----------------------------------------------------------------------
10.RC5
w, r, mod = 32, 12, 2**32
S = []

def rol(x, y): 
    return ((x << (y % w)) | (x >> (w - (y % w)))) & (mod - 1)

def ror(x, y): 
    return ((x >> (y % w)) | (x << (w - (y % w)))) & (mod - 1)

def key_expansion(key):
    global S
    t = 2 * (r + 1)
    S = [0] * t
    S[0] = 0xB7E15163
    for i in range(1, t):
        S[i] = (S[i-1] + 0x9E3779B9) % mod
    
    A = B = i = j = 0
    L = list(key)
    for _ in range(3 * max(t, len(L))):
        A = S[i] = rol((S[i] + A + B) % mod, 3)
        B = L[j] = (rol((L[j] + A + B) % mod, (A + B) % 32)) % 256
        i = (i + 1) % t
        j = (j + 1) % len(L)

def encrypt(a, b):
    a, b = (a + S[0]) % mod, (b + S[1]) % mod
    for i in range(1, r + 1):
        a = (rol(a ^ b, b) + S[2*i]) % mod
        b = (rol(b ^ a, a) + S[2*i+1]) % mod
    return a, b

def decrypt(a, b):
    for i in range(r, 0, -1):
        b = ror((b - S[2*i+1]) % mod, a) ^ a
        a = ror((a - S[2*i]) % mod, b) ^ b
    return (a - S[0]) % mod, (b - S[1]) % mod

def text_to_blocks(t):
    d = [ord(c) for c in t]
    if len(d) % 2: 
        d.append(0)
    return d

def blocks_to_text(b, l): 
    return ''.join(chr(x) for x in b[:l])

def main():
    pt = input("Enter plaintext: ")
    key_expansion(b"MySecretKey12345")
    
    tb = text_to_blocks(pt)
    cb = []
    for i in range(0, len(tb), 2):
        cb += encrypt(tb[i], tb[i+1])
    print("\nCiphertext blocks:", cb)

    db = []
    for i in range(0, len(cb), 2):
        db += decrypt(cb[i], cb[i+1])
    print("Decrypted plaintext:", blocks_to_text(db, len(pt)))

if __name__ == "__main__":
    main()
------------------------------------------------------------------------------------------
11.BlowFish
from Crypto.Cipher import Blowfish
from Crypto.Util.Padding import pad, unpad
import base64
# Input
msg = input("Enter text: ")

key = input("Enter key (max 16 chars): ").encode()

# Ensure key length is valid (4 to 16 bytes)

if len(key) < 4 or len(key) > 16:

    raise ValueError("Key must be between 4 and 16 characters.")

# Encrypt

cipher = Blowfish.new(key, Blowfish.MODE_ECB)

enc_bytes = cipher.encrypt(pad(msg.encode(), Blowfish.block_size))

enc_b64 = base64.b64encode(enc_bytes).decode()

print("Encrypted:", enc_b64)

# Decrypt
cipher_dec = Blowfish.new(key, Blowfish.MODE_ECB)

dec_bytes = cipher_dec.decrypt(base64.b64decode(enc_b64))

dec_msg = unpad(dec_bytes, Blowfish.block_size).decode()

print("Decrypted:",dec_msg)
------------------------------------------------------------------------------
12.RSA
p = 17
q = 19
n = p * q
phi = (p - 1) * (q - 1)
e = 11
for i in range(1, phi):
    if (e * i) % phi == 1:
        d = i
        break
public_key = (e, n)
private_key = (d, n)
print("Public Key:", public_key)
print("Private Key:", private_key)
def encrypt(text, pub_key):
    e, n = pub_key
    cipher = []
    for ch in text:
        if ch.isalpha():
            m = ord(ch.lower()) - ord('a')
            C = pow(m, e, n)
            cipher.append(C)
    return cipher
def decrypt(cipher, priv_key):
    d, n = priv_key
    text = ""
    for C in cipher:
        m = pow(C, d, n)
        text += chr(m + ord('A'))
    return text
plain_text = input("Enter text (letters only): ")
cipher_text = encrypt(plain_text, public_key)
print("Cipher (numbers):", cipher_text)
decrypted_text = decrypt(cipher_text, private_key)
print("Decrypted Text:",decrypted_text)
